--- A collection of reusable Cairo patterns
local color      = require( "gears.color"    )
local surface    = require( "gears.surface"  )
local cairo      = require( "lgi"            ).cairo

local blind_pat = {sur={},mask={}}

--- Convert a surface to a pattern
function blind_pat.to_pattern(img)
    local pat = cairo.Pattern.create_for_surface(img)
    pat:set_extend(cairo.Extend.REPEAT)
    return pat
end

--- Create a 45 degree stipped pattern
-- @arg col1 the first color
-- @arg col2 the second color (option, will be autogenerated)
-- @arg the pattern height (in pixel)
-- @arg horizontal_repetition number of pixels between lines (default = 4)
-- @arg right to left (default = false)
function blind_pat.sur.flat_grad(col1,col2,height,horizontal_repetition,rtl)
    local pat3,pat4 = color(col1),col2 and color(col2) or nil
    -- If there is only one color, then build the second one
    if not col2 then
        local s,r,g,b,a = pat3:get_rgba()
        pat3 = cairo.Pattern.create_rgb((r-0.1)/3,(g-0.1)/3,(b-0.1)/3)
        pat4 = cairo.Pattern.create_rgb((r-0.1)*1.2,(g-0.1)*1.2,(b-0.1)*1.2)
    end
    local w = horizontal_repetition or 4
    -- The lines need to be aligned by muliples of their horizontal repetition
    local rep = math.floor(height/w)
    local multiple = w*( rep + 1)

    local img = cairo.ImageSurface.create(cairo.Format.ARGB32, w, multiple)
    local cr  = cairo.Context(img)
    cr:set_source(pat3)
    cr:paint()
    cr:set_source(pat4)
    cr:set_antialias(cairo.ANTIALIAS_NONE)
    cr:set_line_width(1)
    for i=0,rep do
        cr:move_to(0,i*4)
        cr:line_to(4,(i+1)*4)
        cr:stroke()
    end
    return img,cr
end

function blind_pat.sur.plain(col,height)
    local img = cairo.ImageSurface.create(cairo.Format.ARGB32, 1, height)
    local cr  = cairo.Context(img)
    cr:set_source(color(col))
    cr:paint()
    return img,cr
end

--- Add a 3D effect to a surface
function blind_pat.mask.ThreeD(img,cr)
    local c1,c2 = "#ffffff","#77777755"
    local mixgrad = { type = "linear", from = { 0, 0 }, to = { 0, img:get_height() }, stops = { { 0.2, c1 }, { 1, c2 }}}
    local grabpat = color(mixgrad)
    cr:set_source(grabpat)
    cr:set_operator(cairo.Operator.OVERLAY)
    cr:paint_with_alpha(1)
    return img,cr
end

--- Create thick 45 degree stripes
function blind_pat.sur.thick_stripe(col1,col2,width,height,rtl)
    local img = cairo.ImageSurface.create(cairo.Format.ARGB32, width*2, height)
    local cr  = cairo.Context(img)
    local multiple = math.ceil(height/(width*2))
    cr:set_source(color(col2))
    cr:rectangle(0,0,width*2,height)
    cr:fill()
    cr:set_source(color(col1))
    for i=0,multiple do
        cr:move_to(0,i*width*2)
        cr:line_to(width*2,(i+1)*width*2)
        cr:line_to(2*width+width,(i+1)*width*2)
        cr:line_to(width,(i)*width*2)
        cr:fill()
    end
    return img,cr
end

local function resize(img,w,h)
    local img2 = cairo.ImageSurface.create(cairo.Format.ARGB32, w, h)
    local cr   = cairo.Context(img2)
    cr:set_source(blind_pat.to_pattern(img))
    cr:paint()
    return img2, cr
end

function blind_pat.mask.resize(w,h,img,cr)
    local img2 = cairo.ImageSurface.create(cairo.Format.ARGB32, w, h)
    local cr   = cairo.Context(img2)
    cr:set_source(blind_pat.to_pattern(img))
    cr:paint()
    return img2, cr
end

--- Draw triangles on to of img
-- @arg size The size of the triangles
-- @arg border The border size
-- @arg cols an array of colors for the triangles
-- @arg border_col The triangle border color
-- @arg img A surface
-- @arg cr A cairo context
function blind_pat.mask.triangle(size, border, cols, border_col, img,cr)
    local w,h = img:get_width(),img:get_height()

    -- The width need to be a multiple of the size or repetition will be wrong
    if w < size or math.floor(w%size) > 0 then
        w,h = math.ceil(w/size)*size,h
        img,cr = resize(img,w,h)
    end

    local multiple_w,muliple_h = math.ceil(w/size),math.ceil(h/size)

    for i=0, multiple_w do
        for j=0, muliple_h do
            -- First triangle
            cr:move_to(i*size, j*size)
            cr:line_to(i*size + size,j*size)
            cr:line_to(i*size + math.ceil(size/2), j*size + size)
            cr:close_path()
            if border > 0 then
                cr:set_source(color(border_col))
                cr[#cols > 0 and "stroke_preserve" or "stroke"](cr)
            end
            local c = cols[1]
            if c then
                cr:set_source(c)
                cr:fill()
            end

            -- Second triangle
            c = cols[2]
            if c then
                cr:set_source(c)
                cr:move_to(i*size + size, j*size)
                cr:line_to(i*size + size             , j*size + size)
                cr:line_to(i*size + math.ceil(size/2), j*size + size)
                cr:fill()
                cr:move_to(i*size, j*size)
                cr:line_to(i*size + math.ceil(size/2), j*size + size)
                cr:line_to(i*size, j*size + size)
                cr:fill()
            end
        end
    end

    return img,cr
end

function blind_pat.mask.honeycomb(size, border, cols, border_col, img,cr)
    local w,h = img:get_width(),img:get_height()
    local dx = size/3
    local dy = size/2
    local wi = (2*dx)

    -- The surface size has to be a multiple of size
    if w < size or math.floor(w%(4*dx)) > 0 then
        w,h = math.ceil(w/size)*size,h
        img,cr = resize(img,w,h)
    end

    cr:set_source(color(border_col or cols[1]))
    local multiple_w,muliple_h = math.ceil(w/wi),math.ceil(h/size)
    for j=0, muliple_h do
        local m = false
        for i=0, multiple_w do
            local dy_ = m and (-dy) or 0
            cr:move_to(i*wi + 2*dx, j*size+dy_)
            cr:line_to(i*wi + dx, j*size+dy_)
            cr:line_to(i*wi, j*size+dy+dy_)
            cr:line_to(i*wi + dx, j*size+size+dy_)
            cr:stroke()
            m = not m
        end
    end
    return img,cr
end

function blind_pat.sur.carbon(size, col1, col2, img, cr)
    local img = cairo.ImageSurface.create(cairo.Format.ARGB32, size*2, size*2)
    local cr  = cairo.Context(img)
    cr:set_antialias(cairo.ANTIALIAS_NONE)
    cr:set_source(color(col1))
    cr:paint()
    cr:set_source(color(col2))
--     cr:rectangle(0,0,2*size,size)
--     cr:rectangle(0,2*size,size,2*size)
--     cr:rectangle(2*size,0,size,2*size)
--     cr:rectangle(2*size,2*size,size,2*size)
    cr:rectangle(0,0,size,size)
    cr:rectangle(size,size,size,size)
    cr:fill()
    return img,cr
end

function blind_pat.mask.circles()
    --TODO draw random sized cicles based on the img size
    -- make sure corner cases (literally!) do as expected
end

function blind_pat.mask.noise(strength,base_color,img,cr)
    local w,h = img:get_width(),img:get_height()

    -- It need at least 11x11 to look non-repetitive
    if w < 11 or h < 11 then
        w,h = w < 11 and 11 or w, h < 11 or h
        img,cr = resize(img,w,h)
    end

    local s,r,g,b,a = color(base_color):get_rgba()
    cr:set_antialias(cairo.ANTIALIAS_NONE)
    for i=0, w do
        for j=0, h do
            local alpha = math.random()*strength
            cr:set_source_rgba(r,g,b,alpha)
            cr:rectangle(i,j,1,1)
            cr:fill()
        end
    end

    return img,cr
end

return blind_pat